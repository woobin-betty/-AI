from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Optional
import anthropic
import os
from datetime import datetime, timedelta
import json

app = FastAPI(title="AI Task Manager API")

# CORS 설정
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Anthropic 클라이언트 초기화
client = anthropic.Anthropic(
    api_key=os.environ.get("ANTHROPIC_API_KEY")
)

# 데이터 모델
class TaskCreate(BaseModel):
    title: str
    description: Optional[str] = ""
    deadline: str

class DailyPlan(BaseModel):
    day: int
    title: str
    duration: str
    focus: str
    tasks: List[str]

class Step(BaseModel):
    title: str
    description: str
    duration: str

class TaskPlan(BaseModel):
    estimatedHours: int
    dailyPlans: List[DailyPlan]
    steps: List[Step]
    checklist: List[str]

class Task(BaseModel):
    id: int
    title: str
    description: str
    deadline: str
    priority: str
    progress: int
    completedSteps: List[int]
    completedDays: List[int]
    plan: TaskPlan

class TaskUpdate(BaseModel):
    completedSteps: Optional[List[int]] = None
    completedDays: Optional[List[int]] = None
    progress: Optional[int] = None


# 메모리 저장소 (실제로는 데이터베이스 사용)
tasks_db = {}


@app.get("/")
def read_root():
    return {"message": "AI Task Manager API", "version": "1.0.0"}


@app.get("/health")
def health_check():
    return {"status": "healthy"}


def calculate_days_until(deadline: str) -> int:
    """마감일까지 남은 일수 계산"""
    deadline_date = datetime.strptime(deadline, "%Y-%m-%d")
    today = datetime.now()
    delta = deadline_date - today
    return max(1, delta.days)


def generate_default_plan(title: str, days_until: int) -> dict:
    """기본 학습 계획 생성 (AI 실패 시 폴백)"""
    plan_days = min(max(days_until, 3), 7)
    
    daily_plans = []
    phases = ["자료 조사 및 분석", "핵심 내용 학습", "실습 및 적용", "정리 및 복습"]
    
    for i in range(plan_days):
        phase_index = min(i // max(1, plan_days // len(phases)), len(phases) - 1)
        phase = phases[phase_index]
        
        daily_plans.append({
            "day": i + 1,
            "title": f"{phase}",
            "duration": "2시간",
            "focus": f"Day {i + 1} 학습 목표 달성",
            "tasks": [
                "관련 자료 검토 및 정리",
                "핵심 개념 학습 및 이해",
                "실습 및 복습"
            ]
        })
    
    return {
        "estimatedHours": plan_days * 2,
        "dailyPlans": daily_plans,
        "steps": [
            {
                "title": "자료 조사",
                "description": "필요한 자료 수집 및 분석",
                "duration": "2시간"
            },
            {
                "title": "학습 진행",
                "description": "핵심 내용 학습 및 이해",
                "duration": f"{plan_days * 2 - 3}시간"
            },
            {
                "title": "정리 및 제출",
                "description": "최종 검토 및 제출 준비",
                "duration": "1시간"
            }
        ],
        "checklist": [
            "모든 요구사항 충족 확인",
            "내용의 정확성 검토",
            "형식 및 체계 확인",
            "제출 기한 재확인"
        ]
    }


def generate_ai_plan(title: str, description: str, days_until: int) -> dict:
    """Claude AI를 사용한 맞춤 학습 계획 생성"""
    try:
        prompt = f"""다음 과제에 대한 구체적인 일일 학습 계획을 생성해주세요:

과제명: {title}
설명: {description if description else '없음'}
남은 기간: {days_until}일

아래 JSON 형식으로만 응답해주세요 (다른 텍스트 없이 JSON만):

{{
  "estimatedHours": 예상_총_시간_숫자,
  "dailyPlans": [
    {{
      "day": 1,
      "title": "1일차 학습 주제",
      "duration": "2시간",
      "focus": "핵심 학습 목표",
      "tasks": ["구체적인 작업1", "구체적인 작업2", "구체적인 작업3"]
    }}
  ],
  "steps": [
    {{
      "title": "단계명",
      "description": "단계별 상세 설명",
      "duration": "예상 소요 시간"
    }}
  ],
  "checklist": ["제출 전 확인사항1", "제출 전 확인사항2", "제출 전 확인사항3"]
}}

중요: 반드시 유효한 JSON 형식으로만 응답하세요."""

        message = client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2000,
            messages=[
                {"role": "user", "content": prompt}
            ]
        )
        
        # 응답에서 텍스트 추출
        response_text = message.content[0].text
        
        # JSON 추출 (마크다운 코드블록 제거)
        response_text = response_text.strip()
        if response_text.startswith("```"):
            lines = response_text.split("\n")
            response_text = "\n".join(lines[1:-1])
        
        # JSON 파싱
        plan = json.loads(response_text)
        
        return plan
        
    except Exception as e:
        print(f"AI 생성 오류: {str(e)}")
        # AI 실패 시 기본 계획 반환
        return generate_default_plan(title, days_until)


@app.post("/api/tasks", response_model=Task)
async def create_task(task: TaskCreate):
    """새 과제 생성 및 AI 학습 계획 생성"""
    try:
        # 남은 일수 계산
        days_until = calculate_days_until(task.deadline)
        
        # 우선순위 결정
        if days_until <= 3:
            priority = "high"
        elif days_until <= 7:
            priority = "medium"
        else:
            priority = "low"
        
        # AI 학습 계획 생성
        plan = generate_ai_plan(task.title, task.description, days_until)
        
        # Task ID 생성
        task_id = int(datetime.now().timestamp() * 1000)
        
        # Task 객체 생성
        new_task = {
            "id": task_id,
            "title": task.title,
            "description": task.description,
            "deadline": task.deadline,
            "priority": priority,
            "progress": 0,
            "completedSteps": [],
            "completedDays": [],
            "plan": plan
        }
        
        # 메모리에 저장
        tasks_db[task_id] = new_task
        
        return new_task
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"과제 생성 실패: {str(e)}")


@app.get("/api/tasks", response_model=List[Task])
async def get_tasks():
    """모든 과제 조회"""
    return list(tasks_db.values())


@app.get("/api/tasks/{task_id}", response_model=Task)
async def get_task(task_id: int):
    """특정 과제 조회"""
    if task_id not in tasks_db:
        raise HTTPException(status_code=404, detail="과제를 찾을 수 없습니다")
    return tasks_db[task_id]


@app.put("/api/tasks/{task_id}", response_model=Task)
async def update_task(task_id: int, task_update: TaskUpdate):
    """과제 업데이트 (진행률, 완료 상태 등)"""
    if task_id not in tasks_db:
        raise HTTPException(status_code=404, detail="과제를 찾을 수 없습니다")
    
    task = tasks_db[task_id]
    
    if task_update.completedSteps is not None:
        task["completedSteps"] = task_update.completedSteps
        # 진행률 자동 계산
        total_steps = len(task["plan"]["steps"])
        completed = len(task_update.completedSteps)
        task["progress"] = int((completed / total_steps) * 100) if total_steps > 0 else 0
    
    if task_update.completedDays is not None:
        task["completedDays"] = task_update.completedDays
    
    if task_update.progress is not None:
        task["progress"] = task_update.progress
    
    tasks_db[task_id] = task
    return task


@app.delete("/api/tasks/{task_id}")
async def delete_task(task_id: int):
    """과제 삭제"""
    if task_id not in tasks_db:
        raise HTTPException(status_code=404, detail="과제를 찾을 수 없습니다")
    
    del tasks_db[task_id]
    return {"message": "과제가 삭제되었습니다"}


@app.get("/api/tasks/today/list")
async def get_today_tasks():
    """오늘 할 일 조회"""
    today_tasks = []
    today = datetime.now()
    
    for task in tasks_db.values():
        if not task["plan"]["dailyPlans"]:
            continue
        
        deadline = datetime.strptime(task["deadline"], "%Y-%m-%d")
        total_days = len(task["plan"]["dailyPlans"])
        task_start = deadline - timedelta(days=total_days - 1)
        
        days_passed = (today - task_start).days
        
        if 0 <= days_passed < total_days:
            today_tasks.append({
                **task,
                "dayIndex": days_passed,
                "todayPlan": task["plan"]["dailyPlans"][days_passed]
            })
    
    return today_tasks


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
